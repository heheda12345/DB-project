# 数据库系统概论 期中报告

> 2017011307 张晨

## 目前进展

完成记录模块、索引模块，进行了简单的单元测试。

### 记录模块

实现了新建文件、删除文件、打开文件、关闭文件、插入记录、删除记录、更新记录、获取属性值满足特定条件的记录。

#### 文件系统设计

* 底层文件系统采用CS346中的页式文件系统，目的是更好地贴合其框架。
* 第一页记录文件中的的记录大小，每页的记录条数，最后一个非满页的位置。剩余空间可用来存储调用方的元数据。
* 之后每一页，使用一个01串表示对应位置是否存在记录，以及一个指向前一个非满页的指针。

#### 优化空间

* 在第一页记录最后一个非满页的位置 ，每一个非满页记录前一个非满页的位置，这构成了一个用链表实现的非满页的栈，再配合每一页开头的01串，可以方便地找到文件系统中的一个空位置。

### 索引模块

实现了新建索引，删除索引，打开索引，关闭索引，插入节点，删除节点，获取属性值满足特定条件的节点。

#### B树vs B+树

在CS346的系统设计中，要求使用B+树存储属性值到RID的映射。我认为这里使用B树实现更为合适。在我的理解中，B+树相比B树主要有以下几点优点：

1. 所有数据均存储在叶子结点，因此内部节点可以存更少的东西，以增加分叉数，降低树高，从而减少IO次数。
2. 叶子节点通过双向链表连接，使得遍历更加方便。

但是，在CS346中，是允许属性值重复的，需要在树中维护同一属性值的所有RID。如果采用B+树实现，在内部节点中不应存属性值的RID，否则B+树的第一条优势将不复存在。但经过我的思考及与同学的讨论，我得出了以下两种可行的实现方式，但是它们都存在自己的问题。

1. 使用属性+RID作为B+树排序的key，但在内部节点仅存属性值，不存RID。每次插入/删除时，通过全局二分节点在树中的排名找到相应的节点。很明显，这种实现方法最大的问题在于多了二分的一个log的复杂度。
2. 仅使用属性作为B+树排序的key。每个叶子结点再使用一个B+树存所有的RID。这种方式首先会大大增加工程难度，其次在性能上也并不优秀。对于重复较多的key，叶子结点中的B+树的深度较大，因而进行访问的时间又较长。但是，重复较多的key一般又正是访问次数较多的key，这使得这种实现方式在理论性能上劣于全局平衡的B+树。

然而，每个节点所需要存的数据仅仅是一个RID，占用的空间不大，因而中间节点省去它并不会明显降低中间节点的存储量。

此外，我认为叶子节点通过双向链表连接，最大的意义是方便工程的实现。但是，使用链表意味着需要对每个数据进行比对，而放弃了树本身能提供的结构信息。如果使用B树实现，对于等于、不等于、大于（等于）、小于（等于）这类基础操作，需要的比较次数会大大降低。

综上所述，我选择B树进行索引。

#### B树的实现

B树的实现参考了数据结构课提供的示例代码。我将数据结构与文件系统的交互抽象成insert, delete, get, update四种操作，将树中存的数据类型和文件系统采用模板表示，以使代码方便地移植到其他工程中。

CS346使用页式文件系统进行，我直接使用记录模块作为B树的底层文件系统，将B树的每个节点视为底层文件系统中的一条记录，B树的元信息包括属性长度、属性类型、B树每个节点的最大元素数、根的存储位置、B树每个节点占用的空间大小。这些元信息也被存在了记录管理中的元信息模块中。

#### 扫描

扫描仅需从根开始按照一定规则对B树进行遍历。现在实现了等于、不等于、大于、大于等于、小于、小于等于共计六种操作。不等于的合法解至多为2段连续区间，其余都至多为1段连续区间。因而，可以通过树的结构推断出某些树中节点所存的袁术一定是/不是合法解，从而进行剪枝及降低比较次数的数量级。

## 存在的问题及困难

1. 对整个工程暂无整体的认识，因而目前仅仅是按CS346的指引实现了这两个模块。
2. 暂时几乎没有做性能优化，但在工程里预留了实现目前想到的几个优化点的可能。若实现完整个系统，发现这些点是性能瓶颈，则会进行相关优化。

## 分工

单人实现，不存在分工。